#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <limits.h>
#include <stdlib.h>
#include <sys/wait.h>

#define CHILD_SIZE 4096 

//writes numbers generated by number argument to child_buffer
//stores the number of values written in the first 4 bytes of child_buffer
void collatz(int* child_buffer, int number);

void printChildNumbers(const int* parent_ptr, int child_index);

//Returns the numbers given as argument in the form of a vector
//If the input is invalid a empty vector is returned
int* getInput(int argc, char* argv[]);

int main(int argc, char* argv[]){
    //Parsing the user input
    int* input_numbers = getInput(argc, argv);
    if (input_numbers == NULL)
        return -1;

    printf("Starting pid: %d\n", getpid());

    //Creating the shared memory object
    char shm_name[] = "myshm";
    int shm_fd = shm_open(shm_name, O_CREAT|O_RDWR, S_IRUSR|S_IWUSR);

    if (shm_fd < 0){
        perror(NULL);
        free(input_numbers);
        return -1;
    }
    //Resizing shared memory object
    size_t shm_size = CHILD_SIZE * (argc - 1);

    if (ftruncate(shm_fd, shm_size) < 0){
        perror(NULL);
        free(input_numbers);
        shm_unlink(shm_name);
        return -1;
    }

    //Mapping the shared object to the parent procces for reading
    int* parent_ptr = mmap(NULL, shm_size, PROT_READ, MAP_SHARED, shm_fd, 0);
    if (parent_ptr == MAP_FAILED){
        perror(NULL);
        free(input_numbers);
        shm_unlink(shm_name);
        return -1;
    }

    //Keeping track of the children pids
    pid_t children_pids[argc - 1];
    for (int i = 0; i < argc - 1; ++i){
        //Creating child procces
        children_pids[i] = fork();
        if (children_pids[i] < 0){
            perror(NULL);
            free(input_numbers);
            shm_unlink(shm_name);
            return -1;
        }
        //Child procces executes collatz and writes to shared memory
        else if (children_pids[i] == 0){
            int* child_buffer = mmap(NULL, CHILD_SIZE, PROT_WRITE,
                                     MAP_SHARED, shm_fd, CHILD_SIZE * i);
            
            //If map fails we exit out of child procces with -1
            if (child_buffer == MAP_FAILED)
                exit(-1);
            
            collatz(child_buffer, input_numbers[i]);
            //If unmap fails we exit out of child procces with -1
            if (munmap(child_buffer, CHILD_SIZE) < 0)
                exit(-1);

            //Exiting out of child procces with succes
            exit(0);
        }
    }

    //Printing the numbers of the children procceses
    //After waiting for them
    for (int i = 0; i < argc - 1; ++i){
        int child_status;
        waitpid(children_pids[i], &child_status, 0);

        //Checking if child was killed by a signal
        if(WIFSIGNALED(child_status))
            printf("Signal number %d terminated procces %d\n",
                   WTERMSIG(child_status), children_pids[i]);
        //Checking if child exited
        else if (WIFEXITED(child_status)){
            //Checking if child exited with error
            if (WEXITSTATUS(child_status) < 0){
                printf("Child %d exited with error: \n", children_pids[i]);
                perror(NULL);
            }
            //if child exited with succes, parent prints it's numbers
            else{
                printf("Child %d: ", children_pids[i]);
                printChildNumbers(parent_ptr, i);
                printf("\n");
            }
        }
    }
    //Freeing remaining resources
    free(input_numbers);

    if (shm_unlink(shm_name) < 0){
        perror(NULL);
        return -1;
    }

    if (munmap(parent_ptr, shm_size)){
        perror(NULL);
        return -1;
    }

    return 0;
}

void collatz(int* child_buffer, int number){
    //First 4 bytes ar for the number of numbers generated with this alg
    int* nr_numbers = child_buffer;
    *nr_numbers = 0;

    //The first element is the number arg
    child_buffer[++(*nr_numbers)] = number;
    while (number != 1){
        if (number % 2 == 0)
            number /= 2;
        else
            number = number * 3 + 1;
        child_buffer[++(*nr_numbers)] = number;
    }
    printf("Finished Me %d, Parent %d\n", getpid(), getppid());
} 

void printChildNumbers(const int* parent_ptr, int child_index){
    //Setting the starting point of the child
    const int* temp = parent_ptr + (child_index * CHILD_SIZE) / sizeof(int);

    //First 4 bytes determine the number of elements
    int nr_elements = *temp;
    printf("Number of elements: %d\n", nr_elements);
    for (int i = 1; i <= nr_elements; ++i)
        printf("%d ", temp[i]);
}

int* getInput(int argc, char* argv[]){
    int* result = NULL;

     if (argc < 2){
	    printf("getInput: Invalid format, correct format: ./file [number]\n");
        return result;
    }
    //Allocating memory for argc - 1 numbers
    result = malloc(sizeof(int) * (argc - 1));
    if (result == NULL){
        perror("getInput");
        return result;
    }

    for (int i = 1; i < argc; ++i){
        char* end;
        int number = strtol(argv[i], &end, 10);

        //Checking if we actually got a number(that is > 0)
        if (number <= 0){
            printf("getInput: Inputed number should be > 0\n");
            return NULL;
        }

        //Checking if the number is out of bounds
        if (number == LONG_MAX || number == LONG_MIN){
            perror("getInput");
            return NULL;
        }
        //Pusing the result into the buffer
        result[i - 1] = number;
    }
    return result;
}